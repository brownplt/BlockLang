* Language of types:

type :=
  Bool
  Num
  Str
  Char
  list type
  function argument type

argument :=
  (listOf type * type * ...) * (n_arity type)


* How I will use type information:

When I write down an expression every part of it must be fully specified, in terms of types.
This requires no extra work with simple expressions, since all the sub-expressions will be typed.

The only place I have to have people put type information then is in the definition of procedures,
since we don't know how to typecheck the arguments.



* Function arguments and return types explicitly provided 

* For expressions, do typechecking.

TypeCheck :: (Expr * TyEnv) -> Boolean
TypeCheck' :: (Expr * TyEnv) -> Type
TypeCheck'' :: (Expr * TyEnv * Type) -> Type
TypeCheck''' :: (Expr * TyEnv * (Type U bottom)) -> (Type U bottom)

* First, hang types on stuff,
* Then, set up drawers and colors, 
* Then, get some sort of typechecking in place.

** I was in the middle of adding type annotations to the builtins in Lib!!!!

Forget about lists and stuff, just get the atomic types working,

also this new syntax for entering type annotations is so much better than the original one,
I can't believe I even tried the other one


** Car and Cdr are first (though I don't actually have a type definition for them,
   and I might as well just comment them out, and just handle list function for the time being

Add in fake placeholder blocks with the appropriate colors, instead of actually coloring holes.

Ghosts, I can then use it for typechecking as well.

File a bug report saying that this functionality is necessary, and asking why it's not there.

List types should be the report.

Start function definition UI. Try and get something implemented.

Get image type working

Get rid of lists?!?

Try to get a definition window working, with a new SVG canvas, but
try to reuse the same toolbox

First, create a new canvas (and toolbox) (which I think are the
constituents of the workspace) for definition of function, then try and
resize it to show that it is on top of current canvas (while
preserving the layout of the toolbox for that new canvas)

Have the answers produced by the evaluation of blocks themselves be
blocks. 

Make it possible to modify test cases and use them in the definition
of a function

Copy expressions into definition window, (look into this)

Big-bang and a place to direct it's output

Priorities:
1. Function definition
2. Image primitives
2. Add in big bang
3. Type checking


* Thoughts on TypeChecking * 
There are two ways in which information about types can propagate
across nodes. Consider the function 'first': It has the type
signature: (Listof Bottom -> Bottom), since we don't have polymorphic types. Let's say we put 
'first' in a context that requires a number. Then we should change the argument type to be a 
(Listof Num) as well. 

Similarly, if we give 'first' a (Listof Num) as an argument, then 
we should expect it to be put in a context of type Num and not anything else. 

We can recursively pass type information down the AST, and back up, and adjust the required types (in context) so that everything fits.

Also, consider If and Cond!!!

