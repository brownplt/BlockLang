* Dependencies

  As checked out originally, the blockly core is provided in compiled
  form ('blockly_compressed.js') so that users who don't want to
  change the core functionality of Blockly don't have to get a local
  copy of the Google Closure library (upon which Blockly depends)
  and can just can add languages and blocks using the high-level
  functions provided by the Blockly core. 

  If you do want to recompile the core, you then need the Closure
  Library dependency, located at '/closure-library'. This
  contains all the UI shared by all of Google's web applications, as
  well as some dependency management for organizing the codebase and
  Google's events library. 

  By default, even if you have the local copy of the Closure Library,
  compilation is still done through the Closure Compiler web API,
  since the Closure Library and the Closure Compiler have to be
  installed separately. I've modified the provided build script
  ('build.py') to do everything locally since online compilation
  wouldn't work without an internet connection and is quite
  slow, as the entire contents of files to be compiled are sent over
  as parameters to the POST request.  

* Interfacing with Whalesong runtime

  The Whalesong runtime provides Javascript versions of (essentially)
  all of the core of Racket, and acts as a virtual machine on top of
  the Javascript runtime, allowing programs it runs to interrupt and
  resume computations, both of which are needed to implement
  continuations and other forms of exceptional control flow. 

  It normally operates by compiling Racket code to Racket bytecode,
  then compiling that bytecode to an intermediate language, and then
  finally to Javascript bytecode which then runs on the Whalesong VM. 

  We want to be able to evaluate arbitrary block programs (corresponding
  to Racket programs) every time a user hits run, without having
  to generate Racket, send that to a server which returns compiled
  Whalesong VM JS, and then finally that. 

  The Whalesong runtime provides the function 'asJavaScriptFunction'
  (located in 'plt.baselib.functions') which takes in a Whalesong
  function, and returns a function that can be called directly from
  ordinary Javascript code, though in a less-than-straightforward
  way. 

  The collection of Racket primitives provided by the Whalesong
  runtime is located at 'plt.baselib.primitives.Primitives'. 

  Here's an example: We have the following expression that we want to
  evaluate: (sin (+ 1 2))

  We can get the javascript functions corresponding to each of the
  primitives as follows: 

  #+BEGIN_SRC js
    
    var sin_prim = plt.baselib.primitives.Primitives['sin'];
    var plus_prim = plt.baselib.primitives.Primitives['+'];
    
    var sinF = plt.baselib.functions.asJavaScriptFunction(sin_prim);
    var plusF = plt.baselib.functions.asJavaScriptFunction(plus_prim);
    
  #+END_SRC

  The calling convention for functions created in this way has them
  taking 2 or more arguments, 
    success: a function of one argument that is executed upon
             successful evaluation of the underlying Racket function
             application. When evaluated, the success function is
             passed the result of the Racket function
             call. (Basically the successful continuation.)
    failure: a function of one argument that is executed upon an
             error or exeception during the evaluation of the
             underlying Racket function application. When evaluated,
             the failure function is passed the error produced by the
             Racket function application. (Basically the failure
             continuation.) 
    args...: Any arguments to the Racket function that is being
             wrapped here. These should be objects of the right type
             that are passed directly to the called function. 

  Furthermore, when the success and failure continuations are called,
  any values they return are not passed back directly to the top
  level that invoked the Racket primitive in the first place. In
  order to get the value resulting from the function invocation and to
  make the generated code more manageable, I define the following
  functions globally, immediately after the Whalesong runtime
  finished loading:

  #+BEGIN_SRC js
    
    var _temp;
    var success = function(v) { _temp = v; };
    var failure = function(e) { 
        throw { message: "Failure!!!", value: v }; 
    };
    var prim_to_js_prim = function(name) { 
        return plt.baselib.functions.asJavaScriptFunction(plt.baselib.primitives.Primitives[name]);
    };
    var call_js_prim = function(prim) { 
        var args = Array.prototype.slice.call(arguments, 1);
        var continuations = [success, failure];
        prim.apply(null, continuations.concat(args));
        return _temp;
    };

  #+END_SRC

  With this in place, The generated code can be relatively
  straightforward. Continuing with the example above, the final
  generated code is:

  #+BEGIN_SRC js

    call_js_prim(prim_to_js_prim('sin'), call_js_prim(prim_to_js_prim('+'), 1, 2));

  #+END_SRC

  This evaluates to 0.1411, which matches exactly the result obtained
  by (sin (+ 1 2)) in WeScheme. 

  I believe this pattern will suffice most (if not all) of the blocks
  that don't extend the namespace (that aren't definitions). Those will
  require deeper integration with the Whalesong VM than here since I
  will have to deal with scope and variable binding and have to be
  very careful about when exactly definitions are introduced into the
  environment.   
  
  That being said, using this pattern (potentially) loses a lot of the
  functionality of the Whalesong VM, since we are working in plain
  Javascript and not bytecode compiled JS. I'm not sure whether this
  approach allows for computations to be interrupted, and I suppose
  that depends at least in part on how the 'asJavaScriptFunction'
  function wraps up the function it is converting to JS.

* Send messages to Blockly mailing list
- Can we define our own shapes, (rounded rectangle)
- Why is there a gap between sub-expression and containing expression, since it can be full

* Make a prototype of some programs that have definitions so that we can see what we are expecting

* Interfacing with the Whalesong Runtime, part 2

  I've added a bunch more helper
  functions to make calling into Whalesong even easier, and to make
  it easier to read the generated code (mostly for the purpose of
  debugging it). The following are also now available when using
  functions from the Whalesong VM:

  #+BEGIN_SRC js

    var ws_apply = function(name) {
        var args = Array.prototype.slice.call(arguments, 1);
        var prim = name_to_js_prim(name);
        return call_js_prim.apply(null, [prim].concat(args));
    };
    var ws_apply_with = function(names /*, ...args */) {
        var args = Array.prototype.slice.call(arguments, 1);
        var prim = ws_prim_to_js_prim(ws_lookup.apply(null, names));
        return call_js_prim.apply(null, [prim].concat(args));
    };
    var ws_prim = function(name) {
        return plt.baselib.primitives.Primitives[name];
    };
    var ws_lookup = function(/* ...args */) {
        var args = Array.prototype.slice.call(arguments);
        var obj = plt.baselib;
        args.forEach(function(arg) {
            obj = obj[arg];
        });
        return obj;
    };
    
  #+END_SRC js

  'ws_apply' neatly captures the most-common use-case, which is using
  a function defined in 'plt.baselib.primitives.Primitives', in which
  case, something like this racket code (or blockly equivalent): '(+
  (sin 4) 8)' can be translated to: 

  #+BEGIN_SRC js

   ws_apply('+', ws_apply('sin', 4), 8)

  #+END_SRC

  When the function to be called is not found in
  'primitives.Primitives', we can use 'ws_apply_with', which will
  take as a first argument any Whalesong created js-function, and
  then the arguments to that function exactly as 'ws_apply' does. 

  The above function is often used in conjunction with 'ws_lookup', which
  takes a variable number of strings to be interpreted as a lookup
  path to some entity reachable from 'plt.baselib' as in the
  following example. The list constructor is not available in
  'primitives.Primitives', so we use the slightly more verbose
  construction of:

  #+BEGIN_SRC js

      ws_apply_with(ws_lookup('lists', 'List'), 1,2,3,4,5)

  #+END_SRC

  to create the Whalesong VM equivalent of '(list 1 2 3 4 5)'.

  'ws_prim' is a convenient shortcut to get a constant defined in
  'primitives.Primitive'. It doesn't add any new functionality.

* Latest status report 
  So at the moment, I have pretty much all of the default Blockly
  blocks for working with strings, numbers, and lists working with
  Whalesong.

  I should be able to easily extend this to booleans, and colors, the
  two other primitive datatypes for which there exist blockly blocks. 

** Handling Control Flow Constructs

   I've been looking into control blocks, however, and they are
   potentially far more challenging.

   I've been reading through Danny's thesis to figure out exactly how
   various control flow constructs are captured in the JS generated by
   Whalesong, and in it he describes the compilation of an if-expression
   (this is Figure 5.14 in the thesis):

   (if <predicate> <true-branch> <false-branch>) compiles to (roughly):

   #+BEGIN_SRC js
          
     var entry = function() { 
         <assembled predicate> 
         if(!MACHINE.valueRegister) 
           return falseBranch(); 
         <assembled true-branch>
         return restOfProgram(); };
     };
     
     var falseBranch = function() { 
         <assembled false-branch>
         return restOfProgram(); 
     };
     
     var restOfProgram = function() { â€¦ };
             
   #+END_SRC

   While this looks relatively easy to generate from an if-expression,
   the problem is that this isn't meant to be run in a naked context, but
   rather in the context of the execution of a full compiled racket
   program, and relies on assumptions about the layout of the machine's
   stack.
   
   As a result, I don't' immediately see it being feasible to generate
   anything that looks like the compiled code for the various control
   flow constructs.
   
   Instead, I was considering an approach that would have me defining all
   the various control flow constructs as racket functions, compiling
   them into the JS that's loaded when the page is initialized (after the
   Whalesong runtime loads), and then just calling these functions
   directly.
   
   Then, I could just generate code to call 'ws_if' with the appropriate
   arguments, and the compiled code would handle all the hard work.
   
   The downside of this approach is that I'm not sure how extensible it
   is, and it's quite possible that not all of Racket's control flow
   cannot be wrapped up in a function without fundamentally changing a
   piece of functionality.
   
   The simple looping constructs for which there are blocks provided by
   Blockly should be handled easily by the pattern, excluding the
   anaphoric loop, which I'm not sure how to handle.
   
   As for more complex Racket forms, such as Cond, this approach should
   also work. I will have to be careful to require arguments to be of the
   correct form so that the wrapped construct is given the right
   arguments, and nothing that would ever be a syntax error is allowed to
   get passed down to the wrapped function. (For Cond, I have to make
   sure that it's not possible to pass multiple questions with no answer,
   or to pass two else clauses to the Cond wrapper function.)
   
   Another problem that this approach might have is that it will change
   error messages, so that there is no longer a one-to-one correspondence
   between errors generated when using WeScheme and errors produced by
   the block editor. (I suppose that this can only be the case if somehow
   we fail to create the blocks in such a way that they will accept
   incorrect numbers or types of arguments. I'll start prototyping this
   shortly, and hopefully be able to speak with more certainty as to
   whether this seems viable shortly.

* Implementing Racket's primitives
  
  Thusfar, I've been trying to implement the default blocks provided
  by Blockly in Whalesong-JS, and not worrying about covering all of
  the primitives provided by the Whalesong VM. There are many
  functions for which there isn't a corresponding block in Blockly. I
  plan to start extending the set of blocks to include blocks for
  each of these functions, and I would like to set it up so that the
  arity information compiled alongside every Whalesong function can
  be used to programmatically determine what the corresponding
  block should look like. That would make it a lot easier to cover
  the entirety of Racket/base, (or at least those functions which we
  are attempting to carry over into the blocklang).
